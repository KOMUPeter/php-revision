
// Debugging with Symfony

// Symfony's debug mode is automatically enabled in the dev environment. You can check this by confirming the environment variable or the APP_ENV setting in .env:

APP_ENV=dev

Ensure config/packages/dev/web_profiler.yaml is enabled:

yaml

    web_profiler:
        toolbar: true
        intercept_redirects: false

b. Symfony Profiler

    Access the Profiler:

    When in the development environment, Symfony provides a toolbar at the bottom of each page. Clicking on it gives you access to the Symfony Profiler, which offers various insights:
        Request: Details about the current request.
        Performance: Timing information for the request.
        Exceptions: Details of any exceptions thrown.
        Logs: View logs generated by your application.

    Profiler Panels:
        Timeline: Shows how long various parts of the request took.
        Database: Displays SQL queries and their execution time.
        Symfony: Gives insight into Symfony-specific operations and services.


c. Logging

    Configure Logging:

    Symfony uses Monolog for logging. Configure logging in config/packages/prod/monolog.yaml or similar based on your environment:

    yaml

monolog:
    channels:
        - deprecation # Deprecations are logged in the dedicated "deprecation" channel when it exists

when@dev:
    monolog:
        handlers:
            main:
                type: stream
                path: "%kernel.logs_dir%/%kernel.environment%.log"
                level: debug
                channels: ["!event"]
            # uncomment to get logging in your browser
            # you may have to allow bigger header sizes in your Web server configuration
            #firephp:
            #    type: firephp
            #    level: info
            #chromephp:
            #    type: chromephp
            #    level: info
            console:
                type: console
                process_psr_3_messages: false
                channels: ["!event", "!doctrine", "!console"]

when@test:
    monolog:
        handlers:
            main:
                type: fingers_crossed
                action_level: error
                handler: nested
                excluded_http_codes: [404, 405]
                channels: ["!event"]
            nested:
                type: stream
                path: "%kernel.logs_dir%/%kernel.environment%.log"
                level: debug

when@prod:
    monolog:
        handlers:
            main:
                type: fingers_crossed
                action_level: error
                handler: nested
                excluded_http_codes: [404, 405]
                buffer_size: 50 # How many messages should be saved? Prevent memory leaks
            nested:
                type: stream
                path: php://stderr
                level: debug
                formatter: monolog.formatter.json
            console:
                type: console
                process_psr_3_messages: false
                channels: ["!event", "!doctrine"]
            deprecation:
                type: stream
                channels: [deprecation]
                path: php://stderr
                formatter: monolog.formatter.json


php

    use Psr\Log\LoggerInterface;

    class MyService
    {
        private $logger;

        public function __construct(LoggerInterface $logger)
        {
            $this->logger = $logger;
        }

        public function doSomething()
        {
            $this->logger->info('Doing something');
        }
    }

d. Using Xdebug

    Install Xdebug:

    Install Xdebug via PECL:

    bash

pecl install xdebug

Configure Xdebug:

Update php.ini to enable Xdebug and configure remote debugging:

ini

    zend_extension=xdebug.so
    xdebug.mode=debug
    xdebug.start_with_request=yes
    xdebug.client_host=127.0.0.1
    xdebug.client_port=9003

    Set Up Your IDE:

    Configure your IDE (e.g., PHPStorm, VSCode) to listen for Xdebug connections. Set breakpoints in your code, and the IDE will pause execution when these breakpoints are hit, allowing you to inspect the state of your application.

3. Symfony Debug Commands

    List Available Commands:

    Symfony provides a set of CLI commands to help with debugging:

    bash

php bin/console list

Debug Commands:

    Debug Container:

    bash

php bin/console debug:container

Lists services in the service container. You can filter by service name or tag.

Debug Routing:

bash

php bin/console debug:router

Shows the routes configured in your application.

Debug Twig:

bash

        php bin/console debug:twig

        Provides information about Twig templates and their usage.

4. Best Practices

    Write Unit Tests:

    Use PHPUnit to write tests for your application. Tests help catch issues early and ensure code correctness.

    Use Assertions:

    Include assertions in your code to verify assumptions. This makes debugging easier when assumptions fail.

    Systematic Debugging:
        Reproduce the Issue: Make sure you can consistently reproduce the problem.
        Narrow Down the Problem: Isolate the problematic code by simplifying your setup.
        Check Logs and Profiler: Look at logs and Symfony Profiler data to understand whatâ€™s happening.

    Version Control:

    Use version control systems like Git to track changes and identify when bugs were introduced.

5. Resources

    Symfony Documentation: Symfony Docs
    PHP Documentation: PHP Manual
    Xdebug Documentation: Xdebug Docs

By leveraging these tools and practices, you'll be well-equipped to debug and troubleshoot issues in your Symfony applications effectively.